ca65 V2.13.2 - (C) Copyright 1998-2005 Ullrich von Bassewitz
Main file   : VIC-SSS-MMX.s
Current file: VIC-SSS-MMX.s

000000r 1               ;*********************************************************************
000000r 1               ; Commodore VIC 20 Software Sprite Stack - MMX Edition
000000r 1               ; last updated: 30-Oct-2011
000000r 1               ; written by Robert Hurst <robert@hurst-ri.us>
000000r 1               ; with contributions from:
000000r 1               ; Matt Dawson <matsondawson@gmail.com>
000000r 1               ;*********************************************************************
000000r 1               
000000r 1               		.fileopt author,	"Robert Hurst"
000000r 1                       .fileopt comment,	"Software Sprite Stack"
000000r 1                       .fileopt compiler,	"VIC 20 ASSEMBLER"
000000r 1               
000000r 1               
000000r 1               ;*********************************************************************
000000r 1               ; To assemble this source using cc65.org project:
000000r 1               ;	ca65.exe --cpu 6502 --listing VIC-SSS-MMX.s
000000r 1               ; Then link it into your project:
000000r 1               ;   ld65.exe -C yourlinker.cfg -o yourgame.prg yourgame.o VIC-SSS-MMX.o
000000r 1               ;
000000r 1               ; See the various .bat files used for working examples.
000000r 1               ;
000000r 1               		.include "VIC-SSS-MMX.h"
000000r 2               ;*********************************************************************
000000r 2               ; Commodore VIC 20 Software Sprite Stack - MMX Edition
000000r 2               ; written by Robert Hurst <robert@hurst-ri.us>
000000r 2               ; last updated: 31-Aug-2014
000000r 2               ;
000000r 2               ; === IMPORTANT ===
000000r 2               ; required symbols you need to define for your game:
000000r 2               ;
000000r 2               ;SPRITEDEF4	= $10		; un-comment this for "repeating" flag usage
000000r 2               ;SPRITEDEF5	= $20		; un-comment this for "ghost" flag usage
000000r 2               ;SPRITEDEF6	= $40		; un-comment this for "collision" flag usage
000000r 2               SPRITEWIDE	= 1			; un-comment this for 16-bit wide sprites
000000r 2               SPRITEMAX	= 5			; reserves this many SPRITE registers (1-?)
000000r 2               SSSNULL		= $20		; your character used for a blank background
000000r 2               
000000r 2               ;*********************************************************************
000000r 2               ; some pertinent VIC 20 symbols
000000r 2               ;
000000r 2               RNDSEED		= $8B		; -$8F: BASIC RND seed value
000000r 2               JIFFYH		= $A0		; jiffy clock high
000000r 2               JIFFYM		= $A1		; jiffy clock med
000000r 2               JIFFYL		= $A2		; jiffy clock low
000000r 2               DATANEXT	= $A6		; DATASETTE pointer (0-191)
000000r 2               KEYCHARS	= $C6		; number of characters in KEYBUF (0-10)
000000r 2               RVSFLAG		= $C7		; character reverse flag
000000r 2               PLAYROWS	= $C8		; current screen row length (16-24)
000000r 2               CURSOR		= $CC		; cursor enable (0=flash)
000000r 2               CRSRCHAR	= $CE		; character under cursor
000000r 2               SCRNLINE	= $D1		; pointer to cursor's screen line
000000r 2               CRSRCOL		= $D3		; position of cursor on screen line
000000r 2               PLAYCOLS	= $D5		; current screen line length (16-24)
000000r 2               CRSRROW		= $D6		; screen row where cursor is
000000r 2               COLORLINE	= $F3		; pointer to cursor's color line
000000r 2               INPUT		= $0200		; -$0258: 89-character BASIC INPUT buffer
000000r 2               KEYBUF		= $0277		; -$0280: 10-character keyboard buffer
000000r 2               COLORCODE	= $0286		; current cursor color
000000r 2               CRSRCOLOR	= $0287		; color under cursor
000000r 2               SCRNPAGE	= $0288		; active screen memory page (unexpanded = $1E)
000000r 2               SHIFTMODE	= $0291		; 0=allow, 128=locked
000000r 2               SCROLLFLAG	= $0292		; auto scrolldown flag
000000r 2               ACOPY		= $030C		; temp storage for A register
000000r 2               XCOPY		= $030D		; temp storage for X register
000000r 2               YCOPY		= $030E		; temp storage for Y register
000000r 2               DATASETTE	= $033C		; -$03FB: 192-byte tape input buffer
000000r 2               MASK		= $8270		; ROM character $40 - Shift-M (\)
000000r 2               VIC			= $9000		; start of Video Interface Chip registers
000000r 2               MACHINE		= $EDE4		; NTSC=$05, PAL=$0C
000000r 2               STOPKEY		= $F770		; check for STOP key pressed
000000r 2               RESET		= $FD22		; warm startup
000000r 2               CHROUT		= $FFD2		; print character with cursor translation
000000r 2               GETIN		= $FFE4		; get a character from keyboard queue
000000r 2               
000000r 2               ;*********************************************************************
000000r 2               ; volatile VIC-SSS symbols
000000r 2               ;
000000r 2               VECTORBG	= $01		; sprite temp pointer to an image source
000000r 2               DIRTYLINE2	= $59		; -$70: 24 screen rows for last dirty column +1
000000r 2               NEWDIRT		= $BF		; bit 7=VIDEO1, 6=VIDEO2, 5=PLAYFIELD, 4=STATIC
000000r 2               DIRTYLINE	= $D9		; -$F0: 24 screen rows for starting dirty column
000000r 2               DIRTMAP		= $F1		; pointer to PLAYCOLOR for dirty-bit updates
000000r 2               VECTORFG	= $F7		; sprite temp pointer to an image target
000000r 2               VECTOR1		= $F9		; sprite temp pointer
000000r 2               VECTOR2		= $FB		; sprite temp pointer
000000r 2               VECTOR3		= $FD		; sprite temp pointer
000000r 2               FPS			= $0285		; number of VIC re-directions every 64-jiffies
000000r 2               PENDING		= $0293		; next video page: $10 or $12
000000r 2               ACTUAL		= $0294		; save VIC startup video page
000000r 2               VSYNC		= $0295		; set when waiting for vertical sync(s)
000000r 2               VSYNC2		= $0296		; frames skipped
000000r 2               VCOUNT		= $0297		; current SSSFLIP count
000000r 2               ;SSSCLIPX	= $0298		; pixels to right border: 8 * (PLAYCOLS + 2)
000000r 2               ;SSSCLIPY	= $0299		; pixels to bottom border: 8 * (PLAYROWS + 2)
000000r 2               SSSCLIPX	= $05		; pixels to right border: 8 * (PLAYCOLS + 2)
000000r 2               SSSCLIPY	= $06		; pixels to bottom border: 8 * (PLAYROWS + 2)
000000r 2               R0			= $029A		; unused temporary register
000000r 2               R1			= $029B		; unused temporary register
000000r 2               R2			= $029C		; unused temporary register
000000r 2               R3			= $029D		; unused temporary register
000000r 2               R4			= $029E		; unused temporary register
000000r 2               
000000r 2               ;*********************************************************************
000000r 2               ; FRAME REGISTERS
000000r 2               ;
000000r 2               VICFRAME1	= $1000		; first video buffer
000000r 2               VICCOLOR1	= $9400		; first color buffer
000000r 2               VICFRAME2	= $1200		; second video buffer
000000r 2               VICCOLOR2	= $9600		; second color buffer
000000r 2               PLAYFIELD	= $1400		; write-pending screen buffer
000000r 2               PLAYCOLOR	= $1600		; write-pending color buffer (bits 0-3)
000000r 2               						; bit 4 = static cell bit, sprites go behind
000000r 2               						; bit 5 = dirty bit for pending page
000000r 2               						; bit 6 = dirty bit for video page 2 only
000000r 2               						; bit 7 = dirty bit for video page 1 only
000000r 2               
000000r 2               ;*********************************************************************
000000r 2               ; SPRITE REGISTERS
000000r 2               ;
000000r 2               .global SSSBUF			; defaults to $1800, but can be relocated by linker
000000r 2               .global SPRITEBACK		; character code this sprite is in collision with
000000r 2               .global	SPRITEBUFH		; pointer within sprite image buffer @ $1800 - $19FF
000000r 2               .global	SPRITEBUFL
000000r 2               .global	SPRITEC1H		; pointer within sprite display character pool
000000r 2               .global	SPRITEC1L
000000r 2               .global SPRITEC2H		; pointer within sprite display character pool
000000r 2               .global SPRITEC2L
000000r 2               .global	SPRITECOL		; 4-bit VIC color code
000000r 2               .global SPRITECX		; sprite collision X-coord
000000r 2               .global SPRITECY		; sprite collision Y-coord
000000r 2               .global	SPRITEDEF		; matrix definition:
000000r 2               						; bit 0: height		0 = 8px; 1 = 16px
000000r 2               						; bit 1: width		0 = 8px; 1 = 16px
000000r 2               						; bit 2: float Y	0=fixed cell; 1=vertical float
000000r 2               						; bit 3: float X	0=fixed cell; 1=horizontal float
000000r 2               						; bit 4: repeat		0=independent; 1=re-use previous
000000r 2               						; bit 5: ghost		0=merge image; 1=invert image
000000r 2               						; bit 6: collision	0=ignore; 1=detect
000000r 2               						; bit 7: enabled	0=invisible; 1=visible
000000r 2               .global	SPRITEH			; number of raster lines (1-16)
000000r 2               .global	SPRITEIMGH		; pointer to source graphic for rendering at 0,0
000000r 2               .global	SPRITEIMGL
000000r 2               .global	SPRITEX			; horizontal pixel coordinate, visible >0 - <SSSCLIPX
000000r 2               .global	SPRITEY			; vertical pixel coordinate, visible >0 - <SSSCLIPY
000000r 2               .global	SPRITEZ			; bit 0: last rendered (0 = SPRITEC1; 1 = SPRITEC2)
000000r 2               						; bit 1: fast copy (0 = merge; 1 = copy)
000000r 2               						; bit 3: sprite-pixel collision with a non-static cell
000000r 2                                       ; bit 4: foreground clipped flag
000000r 2                                       ; bit 5: background is all SSSNULLs
000000r 2               						; bit 6: copy/merge into alternate sprite char pool
000000r 2               						; bit 7: copy/shift sprite image into its buffer
000000r 2               ;--- above registers repeat for each sprite allocated ---
000000r 2               .global sss				; screen row index -- computed by PLAYCOLS
000000r 2               .global	sssALLOC		; table of sprite sizes (in custom characters)
000000r 2               .global	sssCOLS			; sprite size in columns: 1, 2, 3
000000r 2               .global	sssROWS			; sprite size in rows: 1, 2, 3
000000r 2               ;--- above registers need storage assigned
000000r 2               sssNUM		= $90		; current sprite # (0-1)
000000r 2               sssX		= $92		; current sprite width: 0=8w, 1=16w, 2=24w
000000r 2               sssY		= $93		; current sprite height: 0=8h, 1=16h, 2=24h
000000r 2               sssBYTES	= $94		; number of bytes this sprite occupies
000000r 2               sssNEXT		= $95		; offset to adjacent character
000000r 2               sssCHAR		= $96		; next custom character to use on PENDING frame
000000r 2               sssDX		= $97		; delta X counter
000000r 2               sssDY		= $98		; delta Y counter
000000r 2               sssLINE		= $9A		; current sprite make line: 0, 8, 16
000000r 2               sssLINENUM	= $9B		; current sprite line countdown
000000r 2               sssROR1		= $9C		; bit shift register column #1
000000r 2               sssROR2		= $9D		; bit shift register column #2
000000r 2               .ifdef SPRITEWIDE
000000r 2               sssROR3		= $9E		; bit shift register column #3
000000r 2               .endif
000000r 2               sssXFER		= $9F		; transfer to custom character counter
000000r 2               SPRITES		= $B7		; number of active sprite registers (0 - SPRITEMAX)
000000r 2               
000000r 2               ;*********************************************************************
000000r 2               ; Common API entry points
000000r 2               ;
000000r 2               .global	SSSINIT			; must be called first
000000r 2               .global	SSSIRQ			; necessary only if video flip timing is required
000000r 2               .global	SSSCELL
000000r 2               .global	SSSCLEAR
000000r 2               .global	SSSPLOT
000000r 2               .global	SSSPRINT
000000r 2               .global	SSSPRINTS
000000r 2               .global	SSSPEEK			; can be called to read a char from the PLAYFIELD
000000r 2               .global	SSSPEEKXY
000000r 2               .global	SSSPOKE			; can be called to put a char on the PLAYFIELD
000000r 2               .global	SSSCREATE		; must be called to allocate a sprite buffer
000000r 2               .global SSSUSE			; must be called prior to manipulating a sprite
000000r 2               .global	SSSANIM			; must be called to load a sprite image
000000r 2               .global	SSSMOVEXY		; must be called to put a sprite in the visible area
000000r 2               .global SSSTOUCH		; can be called to force a sprite to re-render
000000r 2               .global	SSSREFRESH		; can be called to force all sprites to re-render
000000r 2               .global	SSSFFLIP		; same as FLIP, but may drop a frame refresh for speed
000000r 2               .global	SSSFLIP			; must be called to see updates on the VIC display
000000r 2               ;
000000r 2               ; used internally by SSS, but may have use by program:
000000r 2               ;
000000r 2               .global	SSSCOMMIT
000000r 2               .global	SSSIMAGE
000000r 2               .global SSSMASK
000000r 2               .global	SSSPLOTS
000000r 2               .global	SSSPEEKS
000000r 2               .global	SSSREAD
000000r 2               .global SSSUPDATE
000000r 2               .global	SSSWRITE
000000r 2               ;
000000r 2               ; useful .asciiz translations for SSSPRINTS
000000r 2               ;
000000r 2               .charmap '@', $80
000000r 2               .charmap 'A', $81
000000r 2               .charmap 'B', $82
000000r 2               .charmap 'C', $83
000000r 2               .charmap 'D', $84
000000r 2               .charmap 'E', $85
000000r 2               .charmap 'F', $86
000000r 2               .charmap 'G', $87
000000r 2               .charmap 'H', $88
000000r 2               .charmap 'I', $89
000000r 2               .charmap 'J', $8A
000000r 2               .charmap 'K', $8B
000000r 2               .charmap 'L', $8C
000000r 2               .charmap 'M', $8D
000000r 2               .charmap 'N', $8E
000000r 2               .charmap 'O', $8F
000000r 2               .charmap 'P', $90
000000r 2               .charmap 'Q', $91
000000r 2               .charmap 'R', $92
000000r 2               .charmap 'S', $93
000000r 2               .charmap 'T', $94
000000r 2               .charmap 'U', $95
000000r 2               .charmap 'V', $96
000000r 2               .charmap 'W', $97
000000r 2               .charmap 'X', $98
000000r 2               .charmap 'Y', $99
000000r 2               .charmap 'Z', $9A
000000r 2               .charmap '{', $9B
000000r 2               .charmap '|', $9C	; British pound symbol
000000r 2               .charmap '}', $9D
000000r 2               .charmap '^', $9E	; uparrow symbol
000000r 2               .charmap '`', $9F	; left arrow symbol
000000r 2               .charmap ' ', SSSNULL
000000r 2               .charmap '!', $A1
000000r 2               .charmap '"', $A2
000000r 2               .charmap '#', $A3
000000r 2               .charmap '$', $A4
000000r 2               .charmap '%', $A5
000000r 2               .charmap '&', $A6
000000r 2               .charmap ''', $A7
000000r 2               .charmap '(', $A8
000000r 2               .charmap ')', $A9
000000r 2               .charmap '*', $AA
000000r 2               .charmap '+', $AB
000000r 2               .charmap ',', $AC
000000r 2               .charmap '-', $AD
000000r 2               .charmap '.', $AE
000000r 2               .charmap '/', $AF
000000r 2               .charmap '0', $B0
000000r 2               .charmap '1', $B1
000000r 2               .charmap '2', $B2
000000r 2               .charmap '3', $B3
000000r 2               .charmap '4', $B4
000000r 2               .charmap '5', $B5
000000r 2               .charmap '6', $B6
000000r 2               .charmap '7', $B7
000000r 2               .charmap '8', $B8
000000r 2               .charmap '9', $B9
000000r 2               .charmap ':', $BA
000000r 2               .charmap ';', $BB
000000r 2               .charmap '<', $BC
000000r 2               .charmap '=', $BD
000000r 2               .charmap '>', $BE
000000r 2               .charmap '?', $BF
000000r 2               .charmap '~', $DE	; PI symbol
000000r 2               
000000r 2               
000000r 1               		.segment "SPRITE"
000000r 1               
000000r 1               
000000r 1               ;*********************************************************************
000000r 1               ; Software Sprite Stack INITIALIZATION
000000r 1               ;
000000r 1               ; MUST BE INVOKED ONCE BEFORE USING ANY OTHER SSS CALL
000000r 1               ; Value in COLORCODE will be used to fill the color buffers.
000000r 1               ;
000000r 1               SSSINIT:
000000r 1               		; SSS geometry
000000r 1  AD 02 90     		LDA VIC+$02
000003r 1  29 1F        		AND #$1F
000005r 1  85 D5        		STA PLAYCOLS
000007r 1  0A           		ASL				; CLC
000008r 1  69 04        		ADC #$04
00000Ar 1  0A           		ASL
00000Br 1  0A           		ASL
00000Cr 1  85 05        		STA SSSCLIPX
00000Er 1  AD 03 90     		LDA VIC+$03
000011r 1  29 7E        		AND #$7E
000013r 1  4A           		LSR
000014r 1  85 C8        		STA PLAYROWS
000016r 1  0A           		ASL				; CLC
000017r 1  69 04        		ADC #$04
000019r 1  0A           		ASL
00001Ar 1  0A           		ASL
00001Br 1  85 06        		STA SSSCLIPY
00001Dr 1               		;
00001Dr 1  A9 00        		LDA #$00
00001Fr 1  85 D6        		STA CRSRROW
000021r 1  85 D3        		STA CRSRCOL
000023r 1  A8           		TAY
000024r 1  AA           		TAX
000025r 1  98           @sss:	TYA
000026r 1  9D rr rr     		STA sss+1,X
000029r 1  A5 D3        		LDA CRSRCOL
00002Br 1  9D rr rr     		STA sss,X
00002Er 1  18           		CLC
00002Fr 1  65 D5        		ADC PLAYCOLS
000031r 1  90 01        		BCC @cc
000033r 1  C8           		INY
000034r 1  85 D3        @cc:	STA CRSRCOL
000036r 1  E8           		INX
000037r 1  E8           		INX
000038r 1  E6 D6        		INC CRSRROW
00003Ar 1  A5 D6        		LDA CRSRROW
00003Cr 1  C5 C8        		CMP PLAYROWS
00003Er 1  D0 E5        		BNE @sss
000040r 1                       ;
000040r 1               		; SSS active / pending video page pointers
000040r 1  A9 10        		LDA #>VICFRAME1
000042r 1  8D 88 02     		STA SCRNPAGE
000045r 1  A9 12        		LDA #>VICFRAME2
000047r 1  8D 93 02     		STA PENDING
00004Ar 1  A9 40        		LDA #$40
00004Cr 1  85 BF        		STA NEWDIRT
00004Er 1               		;
00004Er 1               		; kernal init
00004Er 1  A9 01        		LDA #$01
000050r 1  85 C7        		STA RVSFLAG		; character reverse flag
000052r 1               ;		LDA #$80
000052r 1               ;		STA SHIFTMODE	; locked
000052r 1  A9 00        		LDA #$00
000054r 1  8D 92 02     		STA SCROLLFLAG	; disable
000057r 1               		;
000057r 1               		; SPRITE register init
000057r 1  85 B7        		STA SPRITES
000059r 1               		;
000059r 1               		; fill VIC screen / color buffers
000059r 1  A9 20        		LDA #SSSNULL
00005Br 1  20 rr rr     		JSR SSSCLEAR
00005Er 1               		;
00005Er 1               		; VIC register init
00005Er 1  AD 02 90     		LDA VIC+$02
000061r 1  29 7F        		AND #$7F		; if $80 enabled, +$0200 to base screen address
000063r 1  8D 02 90     		STA VIC+$02
000066r 1  A9 CF        		LDA #$CF		; point VIC screen @ $1000 w/ char set @ $1C00
000068r 1               	;	LDA #$C0		; uncomment for debugging display purposes
000068r 1  8D 05 90     		STA VIC+$05
00006Br 1               		;
00006Br 1               		; FRAME register init
00006Br 1  A0 00        		LDY #$00
00006Dr 1               	;	STY FPS
00006Dr 1  8C 95 02     		STY VSYNC
000070r 1  8C 96 02     		STY VSYNC2
000073r 1               	;	STY VCOUNT
000073r 1               	;	JSR SSSFLIP
000073r 1  60           		RTS
000074r 1               
000074r 1               
000074r 1               ;*********************************************************************
000074r 1               ; Software Sprite Stack IRQ HANDLER
000074r 1               ;
000074r 1               ; PROGRAM USE OF THIS HANDLER IS OPTIONAL
000074r 1               ;
000074r 1               ; customize to your liking, i.e.,
000074r 1               ; - change JMP $EABF here to continue to your custom IRQ handler; or
000074r 1               ; - JMP SSSIRQ at the end of your IRQ handler.
000074r 1               ;
000074r 1               SSSIRQ:
000074r 1               	;	LDA JIFFYL
000074r 1               	;	AND #%00111111
000074r 1               	;	BNE @cont
000074r 1               	;	LDX VCOUNT
000074r 1               	;	STX FPS
000074r 1               	;	STA VCOUNT
000074r 1               @cont:
000074r 1  EE 96 02     		INC VSYNC2		; frame skipped?
000077r 1  AD 95 02     		LDA VSYNC
00007Ar 1  F0 11        		BEQ @fskip		; program is NOT waiting ...
00007Cr 1  A2 00        		LDX #$00
00007Er 1  38           		SEC
00007Fr 1  ED 96 02     		SBC VSYNC2
000082r 1  8D 95 02     		STA VSYNC		; save result
000085r 1  B0 03        		BCS @reset		; program wants more than 1 screen refresh
000087r 1  8E 95 02     		STX VSYNC		; clear wait for vertical sync flag
00008Ar 1  8E 96 02     @reset:	STX VSYNC2		; clear frame skip counter
00008Dr 1               @fskip:
00008Dr 1  4C BF EA     		JMP $EABF
000090r 1               
000090r 1               
000090r 1               ;*********************************************************************
000090r 1               ; Software Sprite Stack CLEAR SCREEN
000090r 1               ;
000090r 1               ; Pass A with the character code to fill the PLAYFIELD buffer.
000090r 1               ; Value in COLORCODE will be used to fill the PLAYCOLOR buffer.
000090r 1               ;
000090r 1               ; These changes will go into effect only after a call to SSSFLIP
000090r 1               ;
000090r 1               SSSCLEAR:
000090r 1  48           		PHA				;++ save character fill code
000091r 1  A2 00        		LDX #$00
000093r 1  A0 00        		LDY #$00
000095r 1  20 rr rr     		JSR SSSPLOT		; home "cursor"
000098r 1  98           @reset:	TYA
000099r 1  95 D9        		STA DIRTYLINE,X
00009Br 1  A5 D5        		LDA PLAYCOLS
00009Dr 1  95 59        		STA DIRTYLINE2,X
00009Fr 1  E8           		INX
0000A0r 1  E4 C8        		CPX PLAYROWS
0000A2r 1  D0 F4        		BNE @reset
0000A4r 1               		;
0000A4r 1  68           @cls:	PLA				;--
0000A5r 1  48           		PHA				;++
0000A6r 1  20 rr rr     		JSR SSSPRINT
0000A9r 1  A6 D3        		LDX CRSRCOL
0000ABr 1  D0 F7        		BNE @cls		; loop until column wraps
0000ADr 1  A4 D6        		LDY CRSRROW
0000AFr 1  D0 F3        		BNE @cls		; loop until row wraps, too
0000B1r 1  68           		PLA				;--
0000B2r 1  60           		RTS
0000B3r 1               
0000B3r 1               
0000B3r 1               ;*********************************************************************
0000B3r 1               ; Software Sprite Stack PLOT CURSOR IN FRAME BUFFER
0000B3r 1               ;
0000B3r 1               ; SSSPLOT uses PLAYFIELD frame buffer.
0000B3r 1               ; SSSPLOTS uses PENDING frame buffer.
0000B3r 1               ;
0000B3r 1               ; Pass X/Y with coordinate to put cursor.
0000B3r 1               ;
0000B3r 1               SSSPLOT:
0000B3r 1  A9 14        		LDA #>PLAYFIELD
0000B5r 1  85 D2        		STA SCRNLINE+1
0000B7r 1  A9 16        		LDA #>PLAYCOLOR
0000B9r 1  85 F4        		STA COLORLINE+1
0000BBr 1  D0 09        		BNE SSSPLOTX
0000BDr 1               ;
0000BDr 1               ; PENDING frame cursor (for writing SPRITE chars)
0000BDr 1               SSSPLOTS:
0000BDr 1  AD 93 02     		LDA PENDING
0000C0r 1  85 D2        		STA SCRNLINE+1
0000C2r 1  09 84        		ORA #$84
0000C4r 1  85 F4        		STA COLORLINE+1
0000C6r 1               ;
0000C6r 1               SSSPLOTX:
0000C6r 1  A9 16        		LDA #>PLAYCOLOR
0000C8r 1  85 F2        		STA DIRTMAP+1
0000CAr 1  E4 D5        @x:		CPX PLAYCOLS
0000CCr 1  30 03        		BMI @y
0000CEr 1  A6 D5        		LDX PLAYCOLS
0000D0r 1  CA           		DEX
0000D1r 1  C4 C8        @y:		CPY PLAYROWS
0000D3r 1  30 03        		BMI @ok
0000D5r 1  A4 C8        		LDY PLAYROWS
0000D7r 1  88           		DEY
0000D8r 1  86 D3        @ok:	STX CRSRCOL		; maintain column offset to row
0000DAr 1  84 D6        		STY CRSRROW		; maintain row number
0000DCr 1  98           		TYA
0000DDr 1  0A           		ASL
0000DEr 1  A8           		TAY
0000DFr 1  B9 rr rr     		LDA sss+1,Y
0000E2r 1  F0 06        		BEQ @top
0000E4r 1  E6 D2        		INC SCRNLINE+1
0000E6r 1  E6 F4        		INC COLORLINE+1
0000E8r 1  E6 F2        		INC DIRTMAP+1
0000EAr 1  B9 rr rr     @top:	LDA sss,Y
0000EDr 1  85 D1        		STA SCRNLINE
0000EFr 1  85 F3        		STA COLORLINE
0000F1r 1  85 F1        		STA DIRTMAP
0000F3r 1  A4 D6        		LDY CRSRROW
0000F5r 1  60           		RTS
0000F6r 1               
0000F6r 1               
0000F6r 1               ;*********************************************************************
0000F6r 1               ; Software Sprite Stack PRINT TO A FRAME BUFFER
0000F6r 1               ;
0000F6r 1               ; Like SSSPOKE, writes to current cursor, but also advances it to
0000F6r 1               ; the right (with line/screen wrap) upon completion.
0000F6r 1               ;
0000F6r 1               ; All registers are preserved from this call, for common loop use.
0000F6r 1               ;
0000F6r 1               SSSPRINT:
0000F6r 1  8E 0D 03     		STX XCOPY		; save index registers
0000F9r 1  8C 0E 03     		STY YCOPY
0000FCr 1  20 rr rr     		JSR SSSPOKE
0000FFr 1  E6 D3        		INC CRSRCOL		; cursor right
000101r 1  A5 D3        		LDA CRSRCOL
000103r 1  C5 D5        		CMP PLAYCOLS	; moved past right edge?
000105r 1  90 1B        		BCC @fini		; no, all done
000107r 1  A9 00        		LDA #$00
000109r 1  85 D3        		STA CRSRCOL		; reset to 1st column
00010Br 1  E6 D6        		INC CRSRROW		; and advance down a row
00010Dr 1  A5 D6        		LDA CRSRROW
00010Fr 1  C5 C8        		CMP PLAYROWS	; moved past bottom edge?
000111r 1  B0 21        		BCS @toprow		; yes, wrap back to top
000113r 1  A5 D1        		LDA SCRNLINE	; no, re-calculate new row pointer
000115r 1  18           		CLC
000116r 1  65 D5        		ADC PLAYCOLS
000118r 1  90 04        		BCC @cc
00011Ar 1  E6 D2        		INC SCRNLINE+1
00011Cr 1  E6 F4        		INC COLORLINE+1
00011Er 1  85 D1        @cc:	STA SCRNLINE
000120r 1  85 F3        		STA COLORLINE
000122r 1  A4 D3        @fini:	LDY CRSRCOL
000124r 1  B1 F3        		LDA (COLORLINE),Y
000126r 1  8D 87 02     		STA CRSRCOLOR
000129r 1  B1 D1        		LDA (SCRNLINE),Y
00012Br 1  85 CE        		STA CRSRCHAR
00012Dr 1  AE 0D 03     		LDX XCOPY		; restore index registers
000130r 1  AC 0E 03     		LDY YCOPY
000133r 1  60           		RTS
000134r 1               @toprow:
000134r 1  A9 00        		LDA #$00
000136r 1  85 D6        		STA CRSRROW
000138r 1  85 D1        		STA SCRNLINE
00013Ar 1  85 F3        		STA COLORLINE
00013Cr 1  C6 D2        		DEC SCRNLINE+1
00013Er 1  C6 F4        		DEC COLORLINE+1
000140r 1  D0 E0        		BNE @fini
000142r 1               
000142r 1               
000142r 1               ;*********************************************************************
000142r 1               ; Software Sprite Stack PRINT STRING FROM POINTER ON STACK
000142r 1               ;
000142r 1               ; Will print bytes, until a NULL, following the JSR call here.
000142r 1               ; Carriage control and color codes are interpreted.
000142r 1               ;
000142r 1               SSSPRINTS:
000142r 1  68           		PLA
000143r 1  85 F7        		STA VECTORFG
000145r 1  68           		PLA
000146r 1  85 F8        		STA VECTORFG+1
000148r 1  A0 01        		LDY #$01
00014Ar 1  B1 F7        @loop:	LDA (VECTORFG),Y
00014Cr 1  F0 29        		BEQ @fini
00014Er 1  C9 0D        		CMP #$0D
000150r 1  D0 0F        		BNE @ctrl
000152r 1  98           		TYA
000153r 1  48           		PHA
000154r 1  A4 D6        		LDY CRSRROW
000156r 1  C8           		INY
000157r 1  A2 00        		LDX #0
000159r 1  20 rr rr     		JSR SSSPLOT
00015Cr 1  68           		PLA
00015Dr 1  A8           		TAY
00015Er 1  4C rr rr     		JMP @next
000161r 1  C9 F0        @ctrl:	CMP #$F0
000163r 1  90 08        		BCC @cont		; color code?
000165r 1  29 0F        		AND #$0F		; filter for 16-colors
000167r 1  8D 86 02     		STA COLORCODE	; 0=blk,1=wht,2=red,3=cyn,4=mag,5=grn,6=blu,7=yel
00016Ar 1  4C rr rr     		JMP @next
00016Dr 1  20 rr rr     @cont:	JSR SSSPRINT
000170r 1  C8           @next:	INY
000171r 1  D0 D7        		BNE @loop
000173r 1  E6 F8        		INC VECTORFG+1
000175r 1  D0 D3        		BNE @loop
000177r 1               		;
000177r 1  98           @fini:	TYA
000178r 1  18           		CLC
000179r 1  65 F7        		ADC VECTORFG
00017Br 1  90 02        		BCC @cc
00017Dr 1  E6 F8        		INC VECTORFG+1
00017Fr 1  85 F7        @cc:	STA VECTORFG
000181r 1  A5 F8        		LDA VECTORFG+1
000183r 1  48           		PHA
000184r 1  A5 F7        		LDA VECTORFG
000186r 1  48           		PHA
000187r 1  60           		RTS
000188r 1               
000188r 1               
000188r 1               ;*********************************************************************
000188r 1               ; Software Sprite Stack READ FROM A FRAME BUFFER
000188r 1               ;
000188r 1               ; SSSPEEK reads from PLAYFIELD frame buffer.
000188r 1               ; SSSPEEKS reads from PENDING frame buffer.
000188r 1               ; SSSPEEKXY reads from PLAYFIELD frame buffer, using the sprite pixel
000188r 1               ; coordinate system to determine X/Y cursor positioning.
000188r 1               ;
000188r 1               ; Pass X/Y with the coordinate to put cursor.
000188r 1               ; CRSRCHAR and CRSRCOLOR are filled with values under cursor, with
000188r 1               ; the former returned in Accumulator.
000188r 1               ;
000188r 1               SSSPEEKS:
000188r 1  20 rr rr     		JSR SSSPLOTS
00018Br 1  4C rr rr     		JMP SSSPEEKX
00018Er 1               ;
00018Er 1               ; pixel X/Y
00018Er 1               SSSPEEKXY:
00018Er 1  E0 10        		CPX #$10
000190r 1  90 0C        		BCC @fini		; hidden by left border
000192r 1  E4 05        		CPX SSSCLIPX
000194r 1  B0 08        		BCS @fini		; hidden by right border
000196r 1  C0 10        		CPY #$10
000198r 1  90 04        		BCC @fini		; above top border
00019Ar 1  C4 06        		CPY SSSCLIPY
00019Cr 1  90 01        		BCC @ok			; below bottom border
00019Er 1  60           @fini:	RTS
00019Fr 1  98           @ok:	TYA
0001A0r 1  38           		SEC
0001A1r 1  E9 10        		SBC #$10
0001A3r 1  4A           		LSR
0001A4r 1  4A           		LSR
0001A5r 1  4A           		LSR
0001A6r 1  A8           		TAY
0001A7r 1               		;
0001A7r 1  8A           		TXA
0001A8r 1  38           		SEC
0001A9r 1  E9 10        		SBC #$10
0001ABr 1  4A           		LSR
0001ACr 1  4A           		LSR
0001ADr 1  4A           		LSR
0001AEr 1  AA           		TAX
0001AFr 1               ;
0001AFr 1               SSSPEEK:
0001AFr 1  20 rr rr     		JSR SSSPLOT
0001B2r 1               ;
0001B2r 1               SSSPEEKX:
0001B2r 1  A4 D3        		LDY CRSRCOL
0001B4r 1  B1 F3        		LDA (COLORLINE),Y
0001B6r 1  8D 87 02     		STA CRSRCOLOR
0001B9r 1  B1 D1        		LDA (SCRNLINE),Y
0001BBr 1  85 CE        		STA CRSRCHAR
0001BDr 1  60           		RTS
0001BEr 1               
0001BEr 1               
0001BEr 1               ;*********************************************************************
0001BEr 1               ; Software Sprite Stack WRITE TO A FRAME BUFFER
0001BEr 1               ;
0001BEr 1               ; Pass Accumulator with character code to write to current cursor.
0001BEr 1               ; COLORCODE is used to fill same space with that value.
0001BEr 1               ;
0001BEr 1               SSSPOKE:
0001BEr 1  A4 D3        		LDY CRSRCOL
0001C0r 1  91 D1        		STA (SCRNLINE),Y
0001C2r 1  B1 F1        		LDA (DIRTMAP),Y
0001C4r 1  A6 D2        		LDX SCRNLINE+1
0001C6r 1  E0 14        		CPX #>PLAYFIELD
0001C8r 1  10 0A        		BPL @bg
0001CAr 1  05 BF        		ORA NEWDIRT
0001CCr 1  91 F1        		STA (DIRTMAP),Y	; update sprite's dirty bits only
0001CEr 1               	.ifdef SPRITEDEF5
0001CEr 1               		LDA (COLORLINE),Y
0001CEr 1               		BIT COLORCODE
0001CEr 1               		BMI @color		; keep color in place
0001CEr 1               	.endif
0001CEr 1  AD 86 02     		LDA COLORCODE	; add color directly to map
0001D1r 1  4C rr rr     		JMP @color
0001D4r 1  29 C0        @bg:	AND #%11000000	; keep any sprite dirt
0001D6r 1  09 20        		ORA #%00100000	; dirty this PLAYFIELD cell
0001D8r 1  0D 86 02     		ORA COLORCODE	; add color
0001DBr 1  91 F3        @color:	STA (COLORLINE),Y
0001DDr 1  A6 D6        		LDX CRSRROW
0001DFr 1  A4 D3        		LDY CRSRCOL
0001E1r 1  B5 D9        		LDA DIRTYLINE,X
0001E3r 1  C5 D3        		CMP CRSRCOL
0001E5r 1  90 02        		BCC @ok			; is dirty seek lower than this write?
0001E7r 1  94 D9        		STY DIRTYLINE,X	; start looking for dirty cells from here
0001E9r 1  98           @ok:	TYA
0001EAr 1  D5 59        		CMP DIRTYLINE2,X
0001ECr 1  90 03        		BCC @ok2		; is dirty seek higher than this write?
0001EEr 1  C8           		INY
0001EFr 1  94 59        		STY DIRTYLINE2,X ; stop looking for dirty cells after here
0001F1r 1  60           @ok2:	RTS
0001F2r 1               
0001F2r 1               
0001F2r 1               ;*********************************************************************
0001F2r 1               ; Software Sprite Stack FLIP ACTIVE / PENDING FRAME BUFFERS
0001F2r 1               ;
0001F2r 1               ; Pass Y with the number of vertical sync counts to wait for, or zero
0001F2r 1               ; to make changes visible immediately.
0001F2r 1               ;
0001F2r 1               ; Only the current cursor position is preserved when completed.
0001F2r 1               ;
0001F2r 1               ; If user is holding RUN/STOP key down, the current video frame is
0001F2r 1               ; paused until it is released.
0001F2r 1               ;
0001F2r 1               SSSFFLIP:
0001F2r 1  A9 00        		LDA #$00		; gameplay needs its action to move faster
0001F4r 1  2C 96 02     		BIT VSYNC2
0001F7r 1  10 09        		BPL SSSFLIP2	; do we need to drop a frame?
0001F9r 1  8D 96 02     		STA VSYNC2
0001FCr 1  60           		RTS
0001FDr 1               		;
0001FDr 1               SSSFLIP:
0001FDr 1  A9 00        		LDA #$00
0001FFr 1  8D 96 02     		STA VSYNC2
000202r 1               SSSFLIP2:
000202r 1  A5 D6        		LDA CRSRROW
000204r 1  48           		PHA				;++ save row
000205r 1  A5 D3        		LDA CRSRCOL
000207r 1  48           		PHA				;++ save column
000208r 1  98           		TYA
000209r 1  48           		PHA				;++ save Y (frame count)
00020Ar 1               		;
00020Ar 1               		; Phase I:
00020Ar 1               		; - write any new PLAYFIELD updates to PENDING frame
00020Ar 1               		; - erase any SPRITE characters from PENDING frame
00020Ar 1               		;
00020Ar 1  A9 10        		LDA #%00010000	; clean TOPFIELD dirt only after this update
00020Cr 1  20 rr rr     		JSR SSSCOMMIT
00020Fr 1               		;
00020Fr 1               		; Phase II:
00020Fr 1               		; - render & write SPRITE characters to PENDING frame
00020Fr 1               		;
00020Fr 1  20 rr rr     		JSR SSSUPDATE
000212r 1               		;
000212r 1               		; PHASE III:
000212r 1               		; - signal IRQ to flip video to PENDING frame
000212r 1               		; - wait for the all clear
000212r 1               		;
000212r 1  68           		PLA				;-- restore A (frame count)
000213r 1  A8           		TAY
000214r 1  C8           		INY				; account for a 'missed' frame
000215r 1               	;	INY				; allow for another 'missed' frame
000215r 1  CC 96 02     		CPY VSYNC2
000218r 1  B0 07        		BCS @pace		; is game loop & rendering ok?
00021Ar 1  A0 80        		LDY #$80		; nope, flag next call to SSSFFLIP
00021Cr 1  8C 96 02     		STY VSYNC2		; to skip rendering/flip altogether
00021Fr 1  A9 00        		LDA #$00		; and don't wait for this vsync either
000221r 1  8D 95 02     @pace:	STA VSYNC		; enable screen to flip
000224r 1  AD 95 02     @vsync:	LDA VSYNC
000227r 1  D0 FB        		BNE @vsync		; and wait for it to occur
000229r 1  2C 96 02     		BIT VSYNC2
00022Cr 1  30 03        		BMI @ok
00022Er 1  8D 96 02     		STA VSYNC2		; fast flip, gauge again for next frame
000231r 1               		;
000231r 1  AD 02 90     @ok:	LDA VIC+$02
000234r 1  49 80        		EOR #$80
000236r 1  8D 02 90     		STA VIC+$02		; re-direct VIC to other screen buffer
000239r 1               	;	INC VCOUNT
000239r 1  AD 88 02     		LDA SCRNPAGE
00023Cr 1  8D 93 02     		STA PENDING		; make active screen as pending
00023Fr 1  49 02        		EOR #$02
000241r 1  8D 88 02     		STA SCRNPAGE	; maintain VIC active video page
000244r 1               		;
000244r 1               		; PHASE IV:
000244r 1               		; - write the same PLAYFIELD updates to new PENDING frame
000244r 1               		;
000244r 1  A9 20        		LDA #%00100000	; clean PLAYFIELD dirt as part of this update
000246r 1  20 rr rr     		JSR SSSCOMMIT
000249r 1               		;
000249r 1  68           		PLA				;-- restore X (column)
00024Ar 1  AA           		TAX
00024Br 1  68           		PLA				;-- restore Y (row)
00024Cr 1  A8           		TAY
00024Dr 1  20 rr rr     		JSR SSSPLOT
000250r 1               		;
000250r 1  20 70 F7     @pause:	JSR STOPKEY
000253r 1  D0 13        		BNE @fini
000255r 1               	;	LDA #$00		; clear skipped frame count
000255r 1               	;	STA VSYNC2
000255r 1               	;	STA VCOUNT
000255r 1               	;	=== write any custom PAUSE or RESET code here ===
000255r 1  68           		PLA
000256r 1  68           		PLA
000257r 1               		; reset music and sound channels
000257r 1  A9 00        @cont:	LDA #$00
000259r 1               		.global NOTES
000259r 1  8D rr rr     		STA NOTES
00025Cr 1  A8           		TAY
00025Dr 1  99 0A 90     @snd:	STA VIC+$0A,Y
000260r 1  C8           		INY
000261r 1  C0 04        		CPY #$04
000263r 1  D0 F8        		BNE @snd
000265r 1               		.global MENU
000265r 1  4C rr rr     		JMP MENU
000268r 1               		;
000268r 1  60           @fini:	RTS
000269r 1               
000269r 1               
000269r 1               ;*********************************************************************
000269r 1               ; Software Sprite Stack COMMIT CHANGES TO PENDING FRAME BUFFER
000269r 1               ;
000269r 1               ; pass Accumulator with the PLAYFIELD bit(s) set for cleaning:
000269r 1               ; - bit 7 for video #1
000269r 1               ; - bit 6 for video #2
000269r 1               ; - bit 5 for playfield
000269r 1               ; - bit 4 for topfield
000269r 1               ;
000269r 1               ; SPRITE dirt for the PENDING frame is always cleaned.
000269r 1               ;
000269r 1               ; This is used by SSSFLIP and NOT normally called by user programs.
000269r 1               ;
000269r 1               DIRTYMASK	= $00
000269r 1               CLEANER		= $01		; bit 7=VIDEO1, 6=VIDEO2, 5=PLAYFIELD, 4=STATIC
000269r 1               ;
000269r 1               SSSCOMMIT:
000269r 1  AE 93 02     		LDX PENDING
00026Cr 1  E0 10        		CPX #>VICFRAME1	; will flip to video #1 next?
00026Er 1  D0 04        		BNE @scrn2
000270r 1  09 80        		ORA #%10000000	; erase old sprites from video #1
000272r 1  D0 02        		BNE @cont
000274r 1  09 40        @scrn2:	ORA #%01000000	; erase old sprites from video #2
000276r 1  A8           @cont:	TAY
000277r 1  49 FF        		EOR #$FF		; reverse check to clean
000279r 1  85 01        		STA CLEANER
00027Br 1  98           		TYA
00027Cr 1  09 20        		ORA #%00100000	; but always look for PLAYFIELD dirt
00027Er 1  85 00        		STA DIRTYMASK
000280r 1  8A           		TXA
000281r 1  85 FC        		STA VECTOR2+1
000283r 1  09 84        		ORA #$84		; and its COLOR
000285r 1  85 FE        		STA VECTOR3+1
000287r 1  A2 00        		LDX #$00
000289r 1  86 FB        		STX VECTOR2
00028Br 1  86 FD        		STX VECTOR3
00028Dr 1  A0 00        		LDY #$00
00028Fr 1  20 rr rr     		JSR SSSPLOT		; home "cursor"
000292r 1               		;
000292r 1  A2 00        		LDX #$00
000294r 1  B5 59        @forx:	LDA DIRTYLINE2,X
000296r 1  8D 0C 03     		STA ACOPY
000299r 1  B5 D9        		LDA DIRTYLINE,X	; dirty start column for this row
00029Br 1  CD 0C 03     		CMP ACOPY
00029Er 1  B0 33        		BCS @nextx		; reached end of this line?
0002A0r 1  A4 D5        		LDY PLAYCOLS
0002A2r 1  84 BF        		STY NEWDIRT
0002A4r 1  94 D9        		STY DIRTYLINE,X	; reset this line's seek for next commit
0002A6r 1  A0 00        		LDY #$00
0002A8r 1  94 59        		STY DIRTYLINE2,X ; reset this line's end for next commit
0002AAr 1  A8           		TAY				; but start this commit from this column
0002ABr 1  B1 F3        @fory:	LDA (COLORLINE),Y
0002ADr 1  29 E0        		AND #%11100000	; is this cell dirty for ANY update?
0002AFr 1  F0 1C        		BEQ @nexty		; no, skip it
0002B1r 1  94 59        		STY DIRTYLINE2,X ; new ending column for this line
0002B3r 1  F6 59        		INC DIRTYLINE2,X ; new ending column for this line
0002B5r 1  C4 BF        		CPY NEWDIRT
0002B7r 1  B0 04        		BCS @more
0002B9r 1  84 BF        		STY NEWDIRT
0002BBr 1  94 D9        		STY DIRTYLINE,X	; new starting column for this line
0002BDr 1  25 00        @more:	AND DIRTYMASK	; is this cell dirty for THIS update?
0002BFr 1  F0 0C        		BEQ @nexty		; no, skip it
0002C1r 1  B1 F3        		LDA (COLORLINE),Y
0002C3r 1  91 FD        		STA (VECTOR3),Y	; update color cell
0002C5r 1  25 01        		AND CLEANER		; remove this dirt from this cell
0002C7r 1  91 F3        		STA (COLORLINE),Y
0002C9r 1  B1 D1        		LDA (SCRNLINE),Y
0002CBr 1  91 FB        		STA (VECTOR2),Y	; update video cell
0002CDr 1  C8           @nexty:	INY
0002CEr 1  CC 0C 03     		CPY ACOPY
0002D1r 1  90 D8        		BCC @fory
0002D3r 1  A5 D1        @nextx:	LDA SCRNLINE
0002D5r 1  18           		CLC
0002D6r 1  65 D5        		ADC PLAYCOLS
0002D8r 1  90 08        		BCC @cc
0002DAr 1  E6 D2        		INC SCRNLINE+1
0002DCr 1  E6 F4        		INC COLORLINE+1
0002DEr 1  E6 FC        		INC VECTOR2+1
0002E0r 1  E6 FE        		INC VECTOR3+1
0002E2r 1  85 D1        @cc:	STA SCRNLINE
0002E4r 1  85 F3        		STA COLORLINE
0002E6r 1  85 FB        		STA VECTOR2
0002E8r 1  85 FD        		STA VECTOR3
0002EAr 1  E8           		INX
0002EBr 1  E4 C8        		CPX PLAYROWS
0002EDr 1  90 A5        		BCC @forx
0002EFr 1               		;
0002EFr 1  A9 80        		LDA #%10000000
0002F1r 1  AE 93 02     		LDX PENDING
0002F4r 1  E0 12        		CPX #>VICFRAME2	; will flip to video #2 next?
0002F6r 1  D0 02        		BNE @scrn1
0002F8r 1  A9 40        		LDA #%01000000
0002FAr 1  85 BF        @scrn1:	STA NEWDIRT
0002FCr 1  60           		RTS
0002FDr 1               
0002FDr 1               
0002FDr 1               ;*********************************************************************
0002FDr 1               ; Software Sprite Stack CREATE A NEW SPRITE IN THE LIST
0002FDr 1               ;
0002FDr 1               ; pass Accumulator with the SPRITEDEF value (see HEADER)
0002FDr 1               ; pass Y with the SPRITEH value (1-16)
0002FDr 1               ; returns X with sprite index #0 thru SPRITEMAX-1
0002FDr 1               ;
0002FDr 1               SSSCREATE:
0002FDr 1  8C 0E 03     		STY YCOPY
000300r 1  A6 B7        		LDX SPRITES
000302r 1  E0 05        		CPX #SPRITEMAX
000304r 1  90 01        		BCC @cont
000306r 1  60           		RTS				; sorry, increase SPRITEMAX and re-compile
000307r 1               @cont:
000307r 1  9D rr rr     		STA SPRITEDEF,X
00030Ar 1  E0 00        		CPX #$00
00030Cr 1  D0 1A        		BNE @append		; >1 sprite
00030Er 1               		;
00030Er 1               		; this is the first sprite in the list ...
00030Er 1  A9 rr        		LDA #<SSSBUF
000310r 1  A0 rr        		LDY #>SSSBUF
000312r 1  8D rr rr     		STA SPRITEBUFL
000315r 1  8C rr rr     		STY SPRITEBUFH
000318r 1  A0 20        		LDY #$20		; start at top of custom character
00031Ar 1  8E rr rr     		STX SPRITEC1L
00031Dr 1  8C rr rr     		STY SPRITEC1H
000320r 1  8E rr rr     		STX SPRITEC2L
000323r 1  8C rr rr     		STY SPRITEC2H
000326r 1  D0 30        		BNE @compute
000328r 1               @append:
000328r 1               		; copy prior sprite vectors
000328r 1  BD rr rr     		LDA SPRITEBUFL-1,X
00032Br 1  9D rr rr     		STA SPRITEBUFL,X
00032Er 1  BD rr rr     		LDA SPRITEBUFH-1,X
000331r 1  9D rr rr     		STA SPRITEBUFH,X
000334r 1  BD rr rr     		LDA SPRITEC1L-1,X
000337r 1  9D rr rr     		STA SPRITEC2L,X
00033Ar 1  BD rr rr     		LDA SPRITEC1H-1,X
00033Dr 1  9D rr rr     		STA SPRITEC1H,X
000340r 1  9D rr rr     		STA SPRITEC2H,X
000343r 1               	.ifdef SPRITEDEF4
000343r 1               		; repeating sprite?
000343r 1               		LDA SPRITEDEF,X
000343r 1               		AND #SPRITEDEF4
000343r 1               		BNE @same
000343r 1               	.endif
000343r 1               		; no, allocate new image and character buffers
000343r 1  BD rr rr     		LDA SPRITEDEF-1,X
000346r 1  29 0F        		AND #$0F
000348r 1  A8           		TAY
000349r 1  B9 rr rr     		LDA sssALLOC,Y
00034Cr 1  18           		CLC
00034Dr 1  7D rr rr     		ADC SPRITEBUFL,X
000350r 1  90 03        		BCC @cc
000352r 1  FE rr rr     		INC SPRITEBUFH,X
000355r 1  9D rr rr     @cc:	STA SPRITEBUFL,X
000358r 1               @compute:
000358r 1  BD rr rr     		LDA SPRITEDEF,X
00035Br 1  29 0F        		AND #$0F
00035Dr 1  A8           		TAY
00035Er 1  B9 rr rr     		LDA sssALLOC,Y
000361r 1  85 94        		STA sssBYTES
000363r 1               		; vector#2 into custom char set
000363r 1  BD rr rr     		LDA SPRITEC2L,X
000366r 1  38           		SEC
000367r 1  E5 94        		SBC sssBYTES	; account for its entire buffer size
000369r 1  B0 06        		BCS @cc1
00036Br 1  DE rr rr     		DEC SPRITEC2H,X
00036Er 1  DE rr rr     		DEC SPRITEC1H,X
000371r 1  9D rr rr     @cc1:	STA SPRITEC2L,X
000374r 1  9D rr rr     		STA SPRITEC1L,X
000377r 1               		; vector#1 into custom char set
000377r 1  38           		SEC
000378r 1  E5 94        		SBC sssBYTES	; account for its entire buffer size
00037Ar 1  B0 03        		BCS @cc2
00037Cr 1  DE rr rr     		DEC SPRITEC1H,X
00037Fr 1  9D rr rr     @cc2:	STA SPRITEC1L,X
000382r 1  4C rr rr     		JMP @new
000385r 1               		; keep repeating sprite pointing to same custom characters
000385r 1  BD rr rr     @same:	LDA SPRITEC1L-1,X
000388r 1  9D rr rr     		STA SPRITEC1L,X
00038Br 1  BD rr rr     		LDA SPRITEC2L-1,X
00038Er 1  9D rr rr     		STA SPRITEC2L,X
000391r 1  BD rr rr     		LDA SPRITEC2H-1,X
000394r 1  9D rr rr     		STA SPRITEC2H,X
000397r 1  AD 0E 03     @new:	LDA YCOPY
00039Ar 1  9D rr rr     		STA SPRITEH,X
00039Dr 1               	.ifdef SPRITEDEF6
00039Dr 1               		LDA #SSSNULL	; init with nothing in contact
00039Dr 1               		STA SPRITEBACK,X
00039Dr 1               	.endif
00039Dr 1  A9 00        		LDA #$00
00039Fr 1               	.ifdef SPRITEDEF6
00039Fr 1               		STA SPRITECX,X	; init collision X-coord
00039Fr 1               		STA SPRITECY,X	; init collision Y-coord
00039Fr 1               	.endif
00039Fr 1  9D rr rr     		STA SPRITEX,X	; sprite is not in visible area to start
0003A2r 1  9D rr rr     		STA SPRITEY,X
0003A5r 1  9D rr rr     		STA SPRITEZ,X   ; all flags off
0003A8r 1  A6 B7        		LDX SPRITES		; return this new sprite # as initialized
0003AAr 1  86 90        		STX sssNUM
0003ACr 1  E6 B7        		INC SPRITES		; account for the new sprite allocated
0003AEr 1  60           		RTS
0003AFr 1               
0003AFr 1               
0003AFr 1               ;*********************************************************************
0003AFr 1               ; Software Sprite Stack SELECT A SPRITE TO MANIPULATE
0003AFr 1               ;
0003AFr 1               ; pass X index with the SPRITES number (0 - <SPRITEMAX)
0003AFr 1               ; preset values for sssNUM, sssX, sssY, sssBYTES, sssNEXT
0003AFr 1               ;
0003AFr 1               SSSUSE:
0003AFr 1  E4 B7        		CPX SPRITES
0003B1r 1  90 01        		BCC @cont
0003B3r 1  00           		BRK				; debugging is in your future
0003B4r 1  86 90        @cont:	STX sssNUM
0003B6r 1  BD rr rr     		LDA SPRITEDEF,X
0003B9r 1  29 0F        		AND #$0F
0003BBr 1  A8           		TAY
0003BCr 1  29 04        		AND #%00000100	; Y-float enabled?
0003BEr 1  F0 0B        		BEQ @y
0003C0r 1  BD rr rr     		LDA SPRITEY,X
0003C3r 1  29 07        		AND #$07
0003C5r 1  D0 04        		BNE @y
0003C7r 1  98           		TYA
0003C8r 1  29 0B        		AND #%00001011	; shave overflow row off
0003CAr 1  A8           		TAY
0003CBr 1  98           @y:		TYA
0003CCr 1  29 08        		AND #%00001000	; X-float enabled?
0003CEr 1  F0 0B        		BEQ @x
0003D0r 1  BD rr rr     		LDA SPRITEX,X
0003D3r 1  29 07        		AND #$07
0003D5r 1  D0 04        		BNE @x
0003D7r 1  98           		TYA
0003D8r 1  29 07        		AND #%00000111	; shave overflow column off
0003DAr 1  A8           		TAY
0003DBr 1               @x:		;
0003DBr 1  B9 rr rr     		LDA sssALLOC,Y
0003DEr 1  85 94        		STA sssBYTES
0003E0r 1               		;
0003E0r 1  B9 rr rr     		LDA sssROWS,Y
0003E3r 1  85 93        		STA sssY
0003E5r 1  0A           		ASL
0003E6r 1  0A           		ASL
0003E7r 1  0A           		ASL             ; x8
0003E8r 1  85 95        		STA sssNEXT
0003EAr 1               		;
0003EAr 1  B9 rr rr     		LDA sssCOLS,Y
0003EDr 1  85 92        		STA sssX
0003EFr 1  60           @fini:	RTS
0003F0r 1               
0003F0r 1               
0003F0r 1               ;*********************************************************************
0003F0r 1               ; Software Sprite Stack LOAD SPRITE BUFFER WITH NEW IMAGE DATA
0003F0r 1               ;
0003F0r 1               ; SSSUSE must be called prior to point to sprite register entry
0003F0r 1               ; pass Accumulator with this sprite's color
0003F0r 1               ; pass X,Y as the source image pointer
0003F0r 1               ;
0003F0r 1               SSSANIM:
0003F0r 1               ;		STX sssDX
0003F0r 1               ;		LDX sssNUM
0003F0r 1               ;		STA SPRITECOL,X
0003F0r 1               ;		LDA sssDX
0003F0r 1               ;		STA SPRITEIMGL,X
0003F0r 1               ;		TYA
0003F0r 1               ;		STA SPRITEIMGH,X
0003F0r 1               ;		BNE SSSTOUCH
0003F0r 1               
0003F0r 1               
0003F0r 1               ;*********************************************************************
0003F0r 1               ; Software Sprite Stack MOVE A SPRITE TO ABSOLUTE X,Y COORDINATES
0003F0r 1               ;
0003F0r 1               ; SSSUSE must be called prior to point to sprite register entry
0003F0r 1               ; pass X,Y with the sprite coordinates
0003F0r 1               ;
0003F0r 1               SSSMOVEXY:
0003F0r 1               ;		TXA
0003F0r 1               ;		LDX sssNUM
0003F0r 1               ;@x:		STA SPRITEX,X
0003F0r 1               ;@y:		TYA
0003F0r 1               ;		STA SPRITEY,X
0003F0r 1               
0003F0r 1               
0003F0r 1               ;*********************************************************************
0003F0r 1               ; Software Sprite Stack FLAG ALL SPRITES FOR RENDERING
0003F0r 1               ;
0003F0r 1               SSSREFRESH:
0003F0r 1  A6 B7        		LDX SPRITES
0003F2r 1  CA           @loop:	DEX
0003F3r 1  30 05        		BMI @fini
0003F5r 1  20 rr rr     		JSR SSSTOUCH
0003F8r 1  D0 F8        		BNE @loop
0003FAr 1  60           @fini:	RTS
0003FBr 1               
0003FBr 1               
0003FBr 1               ;*********************************************************************
0003FBr 1               ; Software Sprite Stack FLAG A SPRITE FOR RENDERING
0003FBr 1               ;
0003FBr 1               ; Pass X with the sprite#
0003FBr 1               ;
0003FBr 1               SSSTOUCH:
0003FBr 1  BD rr rr     		LDA SPRITEZ,X
0003FEr 1  29 03        		AND #%11		; reset flags, except fast copy + custom char
000400r 1  09 C0        		ORA #%11000000	; force sprite to do make + copy/merge
000402r 1  9D rr rr     		STA SPRITEZ,X
000405r 1  60           		RTS
000406r 1               
000406r 1               
000406r 1               ;*********************************************************************
000406r 1               ; Software Sprite Stack UPDATE PENDING FRAME BUFFER WITH SPRITES
000406r 1               ;
000406r 1               ; This is part of the SSSFLIP operation and is NOT expected to be
000406r 1               ; called by user programs.
000406r 1               ;
000406r 1               SSSUPDATE:
000406r 1  A2 00        		LDX #0
000408r 1  86 90        		STX sssNUM
00040Ar 1               @do:
00040Ar 1  E4 B7        		CPX SPRITES
00040Cr 1  90 01        		BCC @cc
00040Er 1  60           		RTS
00040Fr 1  BD rr rr     @cc:	LDA SPRITEDEF,X
000412r 1               
000412r 1               	.ifdef SPRITEDEF4	; repeating sprite?
000412r 1               		AND #SPRITEDEF4
000412r 1               		BEQ @own
000412r 1               		LDA SPRITEZ-1,X
000412r 1               		STA SPRITEZ,X	; copy Z-flags for display & results
000412r 1               		JMP @matrix
000412r 1               	.else
000412r 1  0A           		ASL
000413r 1  90 4E        		BCC @redraw		; sprite is disabled
000415r 1  BD rr rr     		LDA SPRITEX,X
000418r 1  F0 49        		BEQ @redraw		; 0 = outside left border visible range
00041Ar 1  C5 05        		CMP SSSCLIPX
00041Cr 1  B0 45        		BCS @redraw		; >= outside right border visible range
00041Er 1  BD rr rr     		LDA SPRITEY,X
000421r 1  F0 40        		BEQ @redraw		; 0 = outside top border visible range
000423r 1  C5 06        		CMP SSSCLIPY
000425r 1  B0 3C        		BCS @redraw		; >= outside bottom border visible range
000427r 1               	.endif
000427r 1               
000427r 1                       ; preset sprite image buffer:
000427r 1               		; VECTOR1 = pointer to top-left within sprite matrix
000427r 1               		; VECTOR2&3 = pointer to adjacent chars, as necessary
000427r 1               @own:	;
000427r 1  20 rr rr     		JSR SSSUSE
00042Ar 1  BD rr rr     		LDA SPRITEBUFH,X
00042Dr 1  85 FA        		STA VECTOR1+1
00042Fr 1  85 FC        		STA VECTOR2+1
000431r 1               
000431r 1               	.ifdef SPRITEWIDE
000431r 1  85 FE        		STA VECTOR3+1
000433r 1               	.endif
000433r 1               
000433r 1  BD rr rr     		LDA SPRITEBUFL,X
000436r 1  85 F9        		STA VECTOR1
000438r 1  18           		CLC
000439r 1  65 95        		ADC sssNEXT
00043Br 1  90 04        		BCC @cc1
00043Dr 1  E6 FC        		INC VECTOR2+1
00043Fr 1               
00043Fr 1               	.ifdef SPRITEWIDE
00043Fr 1  E6 FE        		INC VECTOR3+1
000441r 1               	.endif
000441r 1               
000441r 1  85 FB        @cc1:	STA VECTOR2
000443r 1               
000443r 1               	.ifdef SPRITEWIDE
000443r 1  18           		CLC
000444r 1  65 95        		ADC sssNEXT
000446r 1  90 02        		BCC @cc2
000448r 1  E6 FE        		INC VECTOR3+1
00044Ar 1  85 FD        @cc2:	STA VECTOR3
00044Cr 1               	.endif
00044Cr 1               
00044Cr 1               	.ifdef SPRITEDEF5
00044Cr 1               		LDY #$11		; ORA opcode
00044Cr 1               		LDA SPRITEDEF,X
00044Cr 1               		AND #SPRITEDEF5	; ghost image?
00044Cr 1               		BEQ @bit
00044Cr 1               		LDY #$51		; EOR opcode
00044Cr 1               @bit:	TYA
00044Cr 1               		STA @OP1
00044Cr 1               		STA @OP2
00044Cr 1               		EOR #$40		; swap opcode
00044Cr 1               		STA @OP3
00044Cr 1               	.endif
00044Cr 1               
00044Cr 1                       ; branch on make control flags
00044Cr 1  BD rr rr     		LDA SPRITEZ,X
00044Fr 1  0A           		ASL
000450r 1  48           		PHA				; ++
000451r 1  90 03        		BCC @copy		; $80 - (re)make buffered image
000453r 1  20 rr rr     		JSR @Make
000456r 1  68           @copy:	PLA				; --
000457r 1  0A           		ASL
000458r 1  90 03        		BCC @matrix		; $40 - copy buffered image
00045Ar 1  20 rr rr     		JSR @Copy
00045Dr 1               @matrix:
00045Dr 1  20 rr rr     		JSR @Display	; display sprite matrix
000460r 1  4C rr rr     		JMP @loop
000463r 1               @redraw:
000463r 1  BD rr rr     		LDA SPRITEZ,X
000466r 1  29 03        		AND #%11
000468r 1  09 F0        		ORA #%11110000	; make + copy/merge + null bg + clipped fg
00046Ar 1  9D rr rr     		STA SPRITEZ,X
00046Dr 1               @loop:
00046Dr 1  E6 90        		INC sssNUM
00046Fr 1  A6 90        		LDX sssNUM
000471r 1  4C rr rr     		JMP @do
000474r 1               		;
000474r 1               		; INIT PHASE
000474r 1               		; ----------
000474r 1               		; (re)make this sprite's image buffer
000474r 1               @Make:	;
000474r 1  BD rr rr     		LDA SPRITEH,X
000477r 1  85 9F        		STA sssXFER		; sprite image raster count
000479r 1  BD rr rr     		LDA SPRITEY,X
00047Cr 1  29 07        		AND #$07
00047Er 1  18           		CLC
00047Fr 1  65 9F        		ADC sssXFER
000481r 1  85 98        		STA sssDY       ; 1st raster below image
000483r 1               		;
000483r 1               		; VECTORBG = pointer to your compact source image
000483r 1  BD rr rr     		LDA SPRITEIMGL,X
000486r 1  85 01        		STA VECTORBG
000488r 1  BD rr rr     		LDA SPRITEIMGH,X
00048Br 1  85 02        		STA VECTORBG+1
00048Dr 1  A5 95        		LDA sssNEXT
00048Fr 1  85 9B        		STA sssLINENUM  ; this many raster lines to copy
000491r 1  C5 98        		CMP sssDY
000493r 1  B0 0F        		BCS @Mloop		; fits within height of sprite
000495r 1  A5 98        		LDA sssDY
000497r 1  38           		SEC
000498r 1  E5 9B        		SBC sssLINENUM
00049Ar 1  8D 0C 03     		STA ACOPY		; compute how many rasters to clip
00049Dr 1  A5 9F        		LDA sssXFER
00049Fr 1  ED 0C 03     		SBC ACOPY
0004A2r 1  85 9F        		STA sssXFER		; clip image within sprite height
0004A4r 1               @Mloop:
0004A4r 1  A9 00        		LDA #$00		; erase raster registers
0004A6r 1  85 9C        		STA sssROR1
0004A8r 1  85 9D        		STA sssROR2
0004AAr 1               
0004AAr 1               	.ifdef SPRITEWIDE
0004AAr 1  85 9E        		STA sssROR3
0004ACr 1               	.endif
0004ACr 1               
0004ACr 1  C6 9B        		DEC sssLINENUM
0004AEr 1  A4 9B        		LDY sssLINENUM
0004B0r 1  A5 9F        		LDA sssXFER
0004B2r 1  F0 39        		BEQ @Mcopy		; no more rasters to copy - zero them
0004B4r 1  C4 98        		CPY sssDY
0004B6r 1  B0 35        		BCS @Mcopy		; below sprite image - zero this raster
0004B8r 1               @Mxfer:
0004B8r 1  C6 9F        		DEC sssXFER		; copying sprite image rasters
0004BAr 1  A4 9F        		LDY sssXFER
0004BCr 1  B1 01        		LDA (VECTORBG),Y
0004BEr 1  85 9C        		STA sssROR1
0004C0r 1  BD rr rr     		LDA SPRITEDEF,X
0004C3r 1  29 02        		AND #%00000010
0004C5r 1  F0 13        		BEQ @Mxfer2		; 16w ?
0004C7r 1  A0 08        		LDY #$08
0004C9r 1  BD rr rr     		LDA SPRITEDEF,X
0004CCr 1  4A           		LSR
0004CDr 1  90 02        		BCC @Monly8 	; 16h ?
0004CFr 1  A0 10        		LDY #$10
0004D1r 1               @Monly8:
0004D1r 1  98           		TYA
0004D2r 1  18           		CLC
0004D3r 1  65 9F        		ADC sssXFER
0004D5r 1  A8           		TAY
0004D6r 1  B1 01        		LDA (VECTORBG),Y
0004D8r 1  85 9D        		STA sssROR2     ; load adjacent register
0004DAr 1               @Mxfer2:
0004DAr 1  BD rr rr     		LDA SPRITEX,X
0004DDr 1  29 07        		AND #$07
0004DFr 1  F0 0C        		BEQ @Mcopy
0004E1r 1  85 97        		STA sssDX
0004E3r 1  46 9C        @Mx2:	LSR sssROR1
0004E5r 1  66 9D        		ROR sssROR2		; shift into image overflow register #1
0004E7r 1               
0004E7r 1               	.ifdef SPRITEWIDE
0004E7r 1  66 9E        		ROR sssROR3		; shift into image overflow register #2
0004E9r 1               	.endif
0004E9r 1               
0004E9r 1  C6 97        		DEC sssDX
0004EBr 1  D0 F6        		BNE @Mx2
0004EDr 1               @Mcopy:
0004EDr 1  A2 01        		LDX #$01
0004EFr 1  A4 9B        		LDY sssLINENUM
0004F1r 1  A5 9C        		LDA sssROR1
0004F3r 1  91 F9        		STA (VECTOR1),Y
0004F5r 1  E4 92        		CPX sssX
0004F7r 1  F0 0D        		BEQ @Mnext
0004F9r 1  A5 9D        		LDA sssROR2		; write image overflow register #1
0004FBr 1  91 FB        		STA (VECTOR2),Y
0004FDr 1               
0004FDr 1               	.ifdef SPRITEWIDE
0004FDr 1  E8           		INX
0004FEr 1  E4 92        		CPX sssX
000500r 1  F0 04        		BEQ @Mnext
000502r 1  A5 9E        		LDA sssROR3		; write image overflow register #2
000504r 1  91 FD        		STA (VECTOR3),Y
000506r 1               	.endif
000506r 1               
000506r 1               @Mnext:
000506r 1  A6 90                LDX sssNUM
000508r 1  A5 9B        		LDA sssLINENUM
00050Ar 1  F0 03        		BEQ @Mfini
00050Cr 1  4C rr rr     		JMP @Mloop
00050Fr 1  60           @Mfini:	RTS
000510r 1               		;
000510r 1               		; PHASE II
000510r 1               		; --------
000510r 1               		; copy/merge buffered image with background into
000510r 1               		; sprite character matrix
000510r 1               @Copy:	;
000510r 1  BD rr rr             LDA SPRITEZ,X
000513r 1  29 03                AND #%11
000515r 1  49 01        		EOR #%1			; flip to other character set
000517r 1  9D rr rr     		STA SPRITEZ,X
00051Ar 1  29 01        		AND #%1
00051Cr 1  D0 0C        		BNE @Cfb2
00051Er 1  BD rr rr     		LDA SPRITEC1L,X
000521r 1  85 F7        		STA VECTORFG
000523r 1  BD rr rr     		LDA SPRITEC1H,X
000526r 1  85 F8        		STA VECTORFG+1
000528r 1  D0 0A        		BNE @Ccopy
00052Ar 1  BD rr rr     @Cfb2:	LDA SPRITEC2L,X
00052Dr 1  85 F7        		STA VECTORFG
00052Fr 1  BD rr rr     		LDA SPRITEC2H,X
000532r 1  85 F8        		STA VECTORFG+1
000534r 1               @Ccopy:
000534r 1  BD rr rr     		LDA SPRITEX,X
000537r 1  85 97        		STA sssDX
000539r 1  A5 95        		LDA sssNEXT
00053Br 1  85 9A        		STA sssLINE
00053Dr 1  A0 00        		LDY #0
00053Fr 1  84 96        		STY sssCHAR
000541r 1  84 9B        		STY sssLINENUM
000543r 1  8C 0C 03     		STY ACOPY
000546r 1               @Cdocol:
000546r 1  A6 90        		LDX sssNUM
000548r 1  BD rr rr     		LDA SPRITEY,X
00054Br 1  85 98        		STA sssDY
00054Dr 1               @Cbgimage:
00054Dr 1  A6 90        		LDX sssNUM
00054Fr 1  BD rr rr     		LDA SPRITEZ,X
000552r 1  29 02        		AND #%10
000554r 1  D0 0B        		BNE @Cjmp		; fast copy?
000556r 1  A6 97        		LDX sssDX
000558r 1  A4 98        		LDY sssDY
00055Ar 1  20 rr rr     		JSR SSSREAD
00055Dr 1  C9 20        		CMP #SSSNULL
00055Fr 1  D0 03        		BNE @Cmore
000561r 1  4C rr rr     @Cjmp:	JMP @Ccpfast
000564r 1               @Cmore:
000564r 1               ;		LDX sssNUM
000564r 1               ;		LDA CRSRCOLOR
000564r 1               ;		AND #%10000
000564r 1               ;		BEQ @Ccont		; static cell?
000564r 1               ;		LDA SPRITEZ,X
000564r 1               ;		ORA #%10000		; flag that sprite's foreground is clipped
000564r 1               ;		STA SPRITEZ,X
000564r 1               ;		JMP @Cnextrow	; don't bother merging with a background
000564r 1               @Ccont:
000564r 1               
000564r 1               	.ifdef SPRITEDEF4
000564r 1               		LDA SPRITEDEF,X
000564r 1               		AND #SPRITEDEF4
000564r 1               		BNE @Cjmp
000564r 1               	.endif
000564r 1               
000564r 1  A5 CE        		LDA CRSRCHAR
000566r 1  20 rr rr     		JSR SSSIMAGE
000569r 1  86 01        		STX VECTORBG
00056Br 1  84 02        		STY VECTORBG+1
00056Dr 1  A2 00        		LDX #0
00056Fr 1  86 9F        		STX sssXFER
000571r 1  E6 96        		INC sssCHAR     ; flag that there is something behind this sprite
000573r 1               
000573r 1               	.ifdef SPRITEDEF6
000573r 1               		LDY sssNUM
000573r 1               		LDA SPRITEZ,Y
000573r 1               		AND #%1000
000573r 1               		BNE @Ccploop	; already a collision?
000573r 1               		LDA SPRITEDEF,Y
000573r 1               		AND #SPRITEDEF6
000573r 1               		BNE @Ccploopx	; collision detection enabled?
000573r 1               	.endif
000573r 1               
000573r 1               @Ccploop:
000573r 1  A4 9F        		LDY sssXFER		; from ...
000575r 1  B1 01        		LDA (VECTORBG),Y
000577r 1  A4 9B        		LDY sssLINENUM	; to ...
000579r 1  11 F9        @OP1:	ORA (VECTOR1),Y	; opcode modification #1: ORA / EOR
00057Br 1  91 F7        		STA (VECTORFG),Y
00057Dr 1               @Ccpnxt:
00057Dr 1  E6 9B        		INC sssLINENUM
00057Fr 1  E6 9F        		INC sssXFER
000581r 1  E8           		INX
000582r 1  E0 08        		CPX #8
000584r 1  D0 ED        		BNE @Ccploop
000586r 1  F0 0E        		BEQ @Cnextrow
000588r 1               
000588r 1               	.ifdef SPRITEDEF6
000588r 1               @Ccploopx:
000588r 1               		LDY sssXFER		; from ...
000588r 1               		LDA (VECTORBG),Y
000588r 1               		PHA				;++
000588r 1               		LDY sssLINENUM	; to ...
000588r 1               @OP2:	ORA (VECTOR1),Y	; opcode modification #2: ORA / EOR
000588r 1               		STA (VECTORFG),Y
000588r 1               		PLA				;--
000588r 1               @OP3:	EOR (VECTOR1),Y	; opcode modification #3: ORA / EOR
000588r 1               		CMP (VECTORFG),Y
000588r 1               		BEQ @Cnohit		; any overlapping pixel(s)?
000588r 1               		LDY sssNUM
000588r 1               		LDA sssDX
000588r 1               		STA SPRITECX,Y	; save X sprite coord of what was hit
000588r 1               		LDA sssDY
000588r 1               		STA SPRITECY,Y	; save Y sprite coord of what was hit
000588r 1               		LDA CRSRCHAR	; save character code of what was hit
000588r 1               		STA SPRITEBACK,Y
000588r 1               		LDA SPRITEZ,Y
000588r 1               		ORA #%1000		; sprite-pixel collision with non-static cell
000588r 1                       STA SPRITEZ,Y
000588r 1               		BNE @Ccpnxt		; resume normal copy/merge operation
000588r 1               @Cnohit:
000588r 1               		INC sssLINENUM
000588r 1               		INC sssXFER
000588r 1               		INX
000588r 1               		CPX #8
000588r 1               		BNE @Ccploopx
000588r 1               		BEQ @Cnextrow
000588r 1               	.endif
000588r 1               
000588r 1               		; faster copy, because there is no backgound to merge with ...
000588r 1               @Ccpfast:
000588r 1  A2 08        		LDX #8
00058Ar 1  A4 9B        		LDY sssLINENUM
00058Cr 1               @Ccploop2:
00058Cr 1  B1 F9        		LDA (VECTOR1),Y
00058Er 1  91 F7        		STA (VECTORFG),Y
000590r 1  C8           		INY
000591r 1  CA           		DEX
000592r 1  D0 F8        		BNE @Ccploop2
000594r 1  84 9B        		STY sssLINENUM
000596r 1               @Cnextrow:
000596r 1  A5 98        		LDA sssDY
000598r 1  18           		CLC
000599r 1  69 08        		ADC #8
00059Br 1  85 98        		STA sssDY
00059Dr 1  A4 9B        		LDY sssLINENUM
00059Fr 1  C4 9A        		CPY sssLINE
0005A1r 1  F0 03        		BEQ @Cnextcol
0005A3r 1  4C rr rr     		JMP @Cbgimage
0005A6r 1               @Cnextcol:
0005A6r 1  AD 0C 03     		LDA ACOPY
0005A9r 1  18           		CLC
0005AAr 1  65 95        		ADC sssNEXT
0005ACr 1  8D 0C 03     		STA ACOPY
0005AFr 1  85 9B        		STA sssLINENUM
0005B1r 1  A5 9A                LDA sssLINE
0005B3r 1  18                   CLC
0005B4r 1  65 95                ADC sssNEXT
0005B6r 1  85 9A        		STA sssLINE
0005B8r 1  A5 97        		LDA sssDX
0005BAr 1  18           		CLC
0005BBr 1  69 08        		ADC #$08
0005BDr 1  85 97        		STA sssDX
0005BFr 1  C6 92        		DEC sssX
0005C1r 1  F0 03        		BEQ @Cdone
0005C3r 1  4C rr rr     		JMP @Cdocol
0005C6r 1               @Cdone:
0005C6r 1  A5 96        		LDA sssCHAR
0005C8r 1  D0 0A        		BNE @Cfini
0005CAr 1  A6 90        		LDX sssNUM		; all null background, if no new changes occur
0005CCr 1  BD rr rr     		LDA SPRITEZ,X	; don't do a merge on next flip either
0005CFr 1  09 20        		ORA #$20        ; enable this sprite to be re-used as-is
0005D1r 1  9D rr rr             STA SPRITEZ,X   ; on next frame flip
0005D4r 1  60           @Cfini:	RTS
0005D5r 1               		;
0005D5r 1               		; PHASE III
0005D5r 1               		; ---------
0005D5r 1               		; display sprite character matrix
0005D5r 1               		; by row, then by column
0005D5r 1               @Display:
0005D5r 1  A6 90        		LDX sssNUM
0005D7r 1               
0005D7r 1               	.ifdef SPRITEDEF4
0005D7r 1               		LDA SPRITEDEF,X
0005D7r 1               		ASL
0005D7r 1               		BCC @Cfini		; sprite is disabled
0005D7r 1               	.endif
0005D7r 1               
0005D7r 1  20 rr rr     		JSR SSSUSE
0005DAr 1  C6 93        		DEC sssY
0005DCr 1  C6 92        		DEC sssX
0005DEr 1  BD rr rr     		LDA SPRITEX,X
0005E1r 1  85 97        		STA sssDX
0005E3r 1  BD rr rr     		LDA SPRITECOL,X
0005E6r 1  8D 86 02     		STA COLORCODE
0005E9r 1               
0005E9r 1               	.ifdef SPRITEDEF5
0005E9r 1               		LDA SPRITEDEF,X
0005E9r 1               		AND #SPRITEDEF5	; ghost mode?
0005E9r 1               		BEQ @Dok
0005E9r 1               		LDA COLORCODE
0005E9r 1               		ORA #$80
0005E9r 1               		STA COLORCODE	; flag to keep PLAYFIELD colored cells
0005E9r 1               	.endif
0005E9r 1               
0005E9r 1  BD rr rr     @Dok:	LDA SPRITEZ,X
0005ECr 1  29 01        		AND #%1
0005EEr 1  D0 0A        		BNE @Dfb2		; which character set to use?
0005F0r 1  BD rr rr     		LDA SPRITEC1L,X
0005F3r 1  85 F7        		STA VECTORFG
0005F5r 1  BD rr rr     		LDA SPRITEC1H,X
0005F8r 1  D0 08        		BNE @Dchar
0005FAr 1  BD rr rr     @Dfb2:	LDA SPRITEC2L,X
0005FDr 1  85 F7        		STA VECTORFG
0005FFr 1  BD rr rr     		LDA SPRITEC2H,X
000602r 1  85 F8        @Dchar:	STA VECTORFG+1
000604r 1  38           		SEC
000605r 1  E9 1C        		SBC #$1C		; starting page of custom chars
000607r 1  0A           		ASL
000608r 1  0A           		ASL
000609r 1  0A           		ASL
00060Ar 1  0A           		ASL
00060Br 1  0A           		ASL				; x32
00060Cr 1  85 96        		STA sssCHAR
00060Er 1  A5 F7        		LDA VECTORFG
000610r 1  4A           		LSR
000611r 1  4A           		LSR
000612r 1  4A           		LSR				; /8
000613r 1  65 96        		ADC sssCHAR
000615r 1  85 96        		STA sssCHAR		; start with this custom character
000617r 1               @Dcol:
000617r 1  A5 93        		LDA sssY
000619r 1  85 9B        		STA sssLINENUM
00061Br 1  A6 90        		LDX sssNUM
00061Dr 1  BD rr rr     		LDA SPRITEY,X
000620r 1  85 98        		STA sssDY		; custom character row (0, 1?, 2?)
000622r 1               @Drow:
000622r 1  A5 96        		LDA sssCHAR
000624r 1  A6 97        		LDX sssDX
000626r 1  A4 98        		LDY sssDY
000628r 1  20 rr rr     		JSR SSSWRITE	; display it
00062Br 1               @Dskip:
00062Br 1  E6 96        		INC sssCHAR		; account for it, even if it is not displayed
00062Dr 1  A5 9B        		LDA sssLINENUM
00062Fr 1  F0 0C        		BEQ @Dnrow
000631r 1  C6 9B        		DEC sssLINENUM
000633r 1  A5 98        		LDA sssDY
000635r 1  18           		CLC
000636r 1  69 08        		ADC #8
000638r 1  85 98        		STA sssDY		; next Y-pixel
00063Ar 1  4C rr rr     		JMP @Drow
00063Dr 1               @Dnrow:
00063Dr 1  A5 97        		LDA sssDX
00063Fr 1  18           		CLC
000640r 1  69 08        		ADC #8
000642r 1  85 97        		STA sssDX
000644r 1  A5 92        		LDA sssX
000646r 1  F0 05        		BEQ @Dncol
000648r 1  C6 92        		DEC sssX
00064Ar 1  4C rr rr     		JMP @Dcol
00064Dr 1               @Dncol:
00064Dr 1  60           		RTS
00064Er 1               
00064Er 1               
00064Er 1               ;*********************************************************************
00064Er 1               ; Software Sprite Stack GET IMAGE ADDRESS FROM A CHARACTER
00064Er 1               ;
00064Er 1               ; This is used by SSSUPDATE and NOT normally called by user programs.
00064Er 1               ;
00064Er 1               ; Pass A with the character code.
00064Er 1               ; returns X/Y as a pointer to its image source.
00064Er 1               ;
00064Er 1               SSSIMAGE:
00064Er 1  A8           		TAY
00064Fr 1  0A           		ASL
000650r 1  0A           		ASL
000651r 1  0A           		ASL				; x8
000652r 1  AA           		TAX				; save image low byte
000653r 1  98           		TYA
000654r 1  2A           		ROL				; set carry bit
000655r 1  A0 00        		LDY #$00		; point to custom chars
000657r 1  90 01        		BCC @cont		; is character reversed?
000659r 1  C8           		INY
00065Ar 1  2A           @cont:	ROL
00065Br 1  2A           		ROL
00065Cr 1  2A           		ROL
00065Dr 1  29 03        		AND #%00000011
00065Fr 1  19 rr rr     		ORA @vic,Y		; prepend page pointer
000662r 1  A8           		TAY				; save image high byte
000663r 1  60           		RTS
000664r 1               		; VIC custom or ROM characters
000664r 1  1C 80        @vic:	.byte	$1C, $80
000666r 1               
000666r 1               
000666r 1               ;*********************************************************************
000666r 1               ; Software Sprite Stack READ FROM PENDING FRAME BUFFER
000666r 1               ;
000666r 1               ; This is used by SSSUPDATE and NOT normally called by user programs.
000666r 1               ;
000666r 1               ; Pass X/Y with a sprite pixel coordinate.
000666r 1               ; CURSOR is re-plotted to this location.
000666r 1               ; returns Accumulator with character code from PENDING frame buffer,
000666r 1               ; or a SPACE if the coordinate is outside the screen borders.
000666r 1               ; returns X/Y cell coordinates.
000666r 1               ;
000666r 1               SSSREAD:
000666r 1  A9 20        		LDA #SSSNULL	; default to an empty background
000668r 1  E0 10        		CPX #$10
00066Ar 1  90 48        		BCC @fini		; hidden by left border
00066Cr 1  E4 05        		CPX SSSCLIPX
00066Er 1  B0 44        		BCS @fini		; hidden by right border
000670r 1  C0 10        		CPY #$10
000672r 1  90 40        		BCC @fini		; above top border
000674r 1  C4 06        		CPY SSSCLIPY
000676r 1  B0 3C        		BCS @fini		; below bottom border
000678r 1               		;
000678r 1  AD 93 02     		LDA PENDING
00067Br 1  85 D2        		STA SCRNLINE+1
00067Dr 1  A9 16        		LDA #>PLAYCOLOR
00067Fr 1  85 F4        		STA COLORLINE+1
000681r 1               		;
000681r 1  98           		TYA
000682r 1  38           		SEC
000683r 1  E9 10        		SBC #$10
000685r 1  4A           		LSR
000686r 1  4A           		LSR
000687r 1  4A           		LSR				; /8
000688r 1  A8           		TAY
000689r 1  84 D6        		STY CRSRROW
00068Br 1               		;
00068Br 1  8A           		TXA
00068Cr 1  38           		SEC
00068Dr 1  E9 10        		SBC #$10
00068Fr 1  4A           		LSR
000690r 1  4A           		LSR
000691r 1  4A           		LSR				; /8
000692r 1  85 D3        		STA CRSRCOL
000694r 1               		;
000694r 1  98           @ok:	TYA
000695r 1  0A           		ASL
000696r 1  A8           		TAY
000697r 1  B9 rr rr     		LDA sss+1,Y
00069Ar 1  F0 04        		BEQ @top
00069Cr 1  E6 D2        		INC SCRNLINE+1
00069Er 1  E6 F4        		INC COLORLINE+1
0006A0r 1  B9 rr rr     @top:	LDA sss,Y
0006A3r 1  85 D1        		STA SCRNLINE
0006A5r 1  85 F3        		STA COLORLINE
0006A7r 1  A4 D3        		LDY CRSRCOL
0006A9r 1  B1 F3        		LDA (COLORLINE),Y	; read from pending color buffer
0006ABr 1  8D 87 02     		STA CRSRCOLOR
0006AEr 1  B1 D1        		LDA (SCRNLINE),Y	; read from pending video buffer
0006B0r 1  85 CE        		STA CRSRCHAR
0006B2r 1  A4 D6        		LDY CRSRROW
0006B4r 1  60           @fini:	RTS
0006B5r 1               
0006B5r 1               
0006B5r 1               ;*********************************************************************
0006B5r 1               ; Software Sprite Stack WRITE TO PENDING FRAME BUFFER
0006B5r 1               ;
0006B5r 1               ; This is used by SSSUPDATE and NOT normally called by user programs.
0006B5r 1               ;
0006B5r 1               ; Pass X/Y with a sprite pixel coordinate.
0006B5r 1               ; Pass A with SPRITE character code to write to PENDING screen buffer.
0006B5r 1               ; COLORCODE is used to fill same space with that value.
0006B5r 1               ;
0006B5r 1               ; Write does not occur if X/Y lie outside the screen borders.
0006B5r 1               ;
0006B5r 1               SSSWRITE:
0006B5r 1  E0 10        		CPX #$10
0006B7r 1  90 1B        		BCC @fini		; hidden by left border
0006B9r 1  E4 05        		CPX SSSCLIPX
0006BBr 1  B0 17        		BCS @fini		; hidden by right border
0006BDr 1  C0 10        		CPY #$10
0006BFr 1  90 13        		BCC @fini		; above top border
0006C1r 1  C4 06        		CPY SSSCLIPY
0006C3r 1  B0 0F        		BCS @fini		; below bottom border
0006C5r 1  48           		PHA				;++
0006C6r 1  20 rr rr     		JSR SSSPEEKXY
0006C9r 1               ;		LDA CRSRCOLOR
0006C9r 1               ;		AND #$10		; static cell?
0006C9r 1               ;		BEQ @ok
0006C9r 1               ;		PLA				; yes, don't overwrite it!
0006C9r 1               ;		RTS
0006C9r 1               ;		;
0006C9r 1  A6 D3        @ok:	LDX CRSRCOL
0006CBr 1  A4 D6        		LDY CRSRROW
0006CDr 1  20 rr rr     		JSR SSSPLOTS
0006D0r 1  68           		PLA				;--
0006D1r 1  20 rr rr     		JSR SSSPOKE
0006D4r 1  60           @fini:	RTS
0006D5r 1               
0006D5r 1               
0006D5r 1               ;*********************************************************************
0006D5r 1               ; Software Sprite Stack PROTECTED WRITE TO PENDING FRAME BUFFER
0006D5r 1               ;
0006D5r 1               ; Pass X/Y with a screen cell coordinate.
0006D5r 1               ; Pass A with character code to write to PENDING screen buffer.
0006D5r 1               ; COLORCODE is used to fill same space with that value.
0006D5r 1               ;
0006D5r 1               SSSCELL:
0006D5r 1               ;		PHA				;++
0006D5r 1               ;		LDA NEWDIRT
0006D5r 1               ;		STA $01
0006D5r 1               ;		LDA #$10
0006D5r 1               ;		STA NEWDIRT
0006D5r 1               ;		JSR SSSPLOTS
0006D5r 1               ;		PLA				;--
0006D5r 1               ;		JSR SSSPOKE
0006D5r 1               ;		LDA $01
0006D5r 1               ;		STA NEWDIRT
0006D5r 1               ;		RTS
0006D5r 1               
0006D5r 1               
